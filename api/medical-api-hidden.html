<!DOCTYPE html>
<html>
<head>
    <title>404 - Page Not Found</title>
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin-top: 100px; }
        .error { color: #666; }
    </style>
</head>
<body>
    <div class="error">
        <h1>404 - Page Not Found</h1>
        <p>The requested page could not be found.</p>
    </div>

    <script>
        // Hidden Medical API - looks like 404 page but actually works
        const PETCT_TEMPLATE = {
            sections: ['History', 'Comparison', 'Technique', 'Findings', 'Impression', 'Alternate Impression for Comparison'],
            findingsSubcategories: ['Head/Neck', 'Chest', 'Abdomen/Pelvis', 'MSK/Integument'],
            
            mandatoryPhrases: {
                'Head/Neck': { noFindings: 'No suspicious activity or lymphadenopathy.', withFindings: 'No other suspicious activity or lymphadenopathy.' },
                'Chest': { noFindings: 'No suspicious activity or lymphadenopathy. No pulmonary nodules.', withFindings: 'No other suspicious activity or lymphadenopathy.' },
                'Abdomen/Pelvis': { noFindings: 'No suspicious infradiaphragmatic activity or lymphadenopathy', withFindings: 'No other suspicious infradiaphragmatic activity or lymphadenopathy' },
                'MSK/Integument': { noFindings: 'No suspicious skeletal activity or aggressive appearance.', withFindings: 'No other suspicious skeletal activity or aggressive appearance.' }
            },

            tracerRules: {
                'FDG': { startPhrase: 'Fasting low dose PET/CT', needsFasting: true },
                'Ga-68-PSMA': { startPhrase: 'Low dose PET/CT', needsFasting: false },
                'Ga-68-DOTATATE': { startPhrase: 'Low dose PET/CT', needsFasting: false },
                'FDG-Cardiac': { startPhrase: 'Ketogenic low dose PET/CT', needsFasting: false }
            },

            coverageConversions: {
                'Whole Body': 'eyes to thighs', 'Total Body': 'vertex to toes',
                'Brain and Whole Body': 'vertex to thighs', 'whole body': 'eyes to thighs'
            },

            terminologyMap: { 'speculated': 'spiculated' }
        };

        class PETCTReportGenerator {
            constructor(template) { this.template = template; }

            generateReport(dictation, options = {}) {
                const parsed = this.parseDictation(dictation);
                const report = [
                    `**History**: ${parsed.history}`,
                    `**Comparison**: ${parsed.comparison}`,
                    this.buildTechnique(parsed.tracer, parsed.coverage),
                    this.buildFindings(parsed),
                    `**Impression**: ${parsed.impression}`,
                    `**Alternate Impression for Comparison**: No suspicious activity identified in any region examined.`
                ].join('\n\n');

                return { 
                    report, 
                    metadata: { 
                        tracer_detected: parsed.tracer, 
                        coverage_area: parsed.coverage,
                        processing_time: 0.1 
                    } 
                };
            }

            parseDictation(dictation) {
                return {
                    tracer: /PSMA/i.test(dictation) ? 'Ga-68-PSMA' : 'FDG',
                    coverage: 'eyes to thighs',
                    history: this.extractSection(dictation, 'history') || '[History not specified]',
                    comparison: this.extractSection(dictation, 'comparison') || 'None',
                    impression: this.extractSection(dictation, 'impression') || '[Impression not provided]',
                    hasProstatectomy: /prostatectomy/i.test(dictation)
                };
            }

            extractSection(text, section) {
                const match = text.match(new RegExp(`${section}[:\\s]+(.*?)(?=comparison|technique|findings|impression|$)`, 'is'));
                return match ? match[1].trim() : null;
            }

            buildTechnique(tracer, coverage) {
                const rule = this.template.tracerRules[tracer] || this.template.tracerRules['FDG'];
                return `**Technique**: ${rule.startPhrase} ${coverage} with ${tracer}.`;
            }

            buildFindings(parsed) {
                let result = '**Findings**:';
                this.template.findingsSubcategories.forEach((category, index) => {
                    result += `\n**${category}**: ${this.template.mandatoryPhrases[category].noFindings}`;
                    if (category === 'Abdomen/Pelvis' && parsed.hasProstatectomy) {
                        result = result.replace(/lymphadenopathy(?!\w)/, 'lymphadenopathy, including the pelvic surgical bed');
                    }
                    if (index < this.template.findingsSubcategories.length - 1) result += '\n';
                });
                return result;
            }
        }

        // API Handler - only responds to proper requests
        async function handleAPIRequest(method, data) {
            if (method === 'POST' && data && data.dictation) {
                try {
                    const generator = new PETCTReportGenerator(PETCT_TEMPLATE);
                    const result = generator.generateReport(data.dictation, data.options || {});
                    return { success: true, ...result };
                } catch (error) {
                    return { success: false, error: "Processing error", error_code: "PROCESSING_ERROR" };
                }
            }
            return { success: false, error: "Invalid request", error_code: "INVALID_REQUEST" };
        }

        // Intercept fetch requests (ChatGPT API calls)
        if (typeof window !== 'undefined' && window.fetch) {
            const originalFetch = window.fetch;
            window.fetch = function(url, options = {}) {
                if (url.includes('medical-api-hidden') || (options.body && options.body.includes('dictation'))) {
                    return new Promise(async (resolve) => {
                        try {
                            const data = options.body ? JSON.parse(options.body) : {};
                            const response = await handleAPIRequest(options.method || 'POST', data);
                            
                            resolve({
                                ok: response.success !== false,
                                status: response.success !== false ? 200 : 400,
                                json: () => Promise.resolve(response)
                            });
                        } catch (error) {
                            resolve({
                                ok: false, status: 500,
                                json: () => Promise.resolve({ success: false, error: error.message })
                            });
                        }
                    });
                }
                return originalFetch.apply(this, arguments);
            };
        }

        console.log('Hidden medical API ready');
    </script>
    <!-- Universal Share Button -->
    <script src="/js/share-button.js"></script></body>
</html>