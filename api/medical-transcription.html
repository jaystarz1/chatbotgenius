<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical Transcription API</title>
    <meta name="robots" content="noindex, nofollow">
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            margin: 40px; 
            background: #f8f9fa;
        }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .hidden { display: none; }
        .status { padding: 15px; margin: 15px 0; border-radius: 6px; font-weight: 500; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        textarea { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 14px; }
        button { background: #007bff; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-weight: 500; }
        button:hover { background: #0056b3; }
        .result { margin-top: 20px; }
        pre { background: #f8f9fa; padding: 20px; border-radius: 4px; overflow-x: auto; border-left: 4px solid #007bff; }
        .endpoint-info { background: #e7f3ff; padding: 20px; border-radius: 6px; margin-bottom: 30px; }
        .api-section { margin: 30px 0; }
        h1 { color: #2c3e50; margin-bottom: 10px; }
        h2 { color: #34495e; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h3 { color: #5a6c7d; }
        .metadata { background: #f1f3f4; padding: 15px; border-radius: 4px; margin-top: 15px; }
        .metadata strong { color: #5f6368; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè• Medical PET/CT Transcription API</h1>
        
        <div class="endpoint-info">
            <h3>API Endpoint Information</h3>
            <p><strong>URL:</strong> <code>https://thechatbotgenius.com/api/medical-transcription.html</code></p>
            <p><strong>Method:</strong> POST (via JavaScript fetch)</p>
            <p><strong>Purpose:</strong> Convert medical dictation into properly formatted PET/CT reports following strict medical standards</p>
            <p><strong>Status:</strong> <span style="color: #28a745; font-weight: bold;">‚úÖ Active</span></p>
        </div>

        <div class="api-section">
            <h2>Test Interface</h2>
            <p>Use this interface to test the medical transcription functionality:</p>
            
            <h3>Sample Dictation Input:</h3>
            <textarea id="dictation-input" rows="15" placeholder="Paste medical dictation here...">History: Metastatic prostate cancer, status post radical prostatectomy. Rising PSA.
Comparison: PET/CT from March 2024.
PSMA scan whole body.
Findings: 8mm left external iliac lymph node with SUVmax 4.2, image 45 of 130 series 4. 10mm L3 vertebral lesion with SUVmax 5.8, image 78 of 130 series 4. Some coronary calcification noted.
Impression: PSMA-avid metastatic disease in lymph node and spine.</textarea>
            
            <br><br>
            <button onclick="testGeneration()">üîÑ Generate PET/CT Report</button>
            <button onclick="validateDictation()" style="background: #28a745; margin-left: 10px;">‚úÖ Validate Dictation</button>
            <button onclick="clearResults()" style="background: #6c757d; margin-left: 10px;">üóëÔ∏è Clear Results</button>
            
            <div id="result"></div>
        </div>

        <div class="api-section">
            <h2>üìö Usage Examples</h2>
            <h3>JavaScript Fetch Example:</h3>
            <pre><code>// Call the API endpoint
const response = await fetch('https://thechatbotgenius.com/api/medical-transcription.html', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        dictation: "Your medical dictation text here...",
        options: {
            include_image_references: true,
            convert_measurements: true,
            strict_formatting: true
        }
    })
});

const result = await response.json();
console.log(result.report);</code></pre>
        </div>
    </div>

    <script>
        // Enhanced PET/CT Template based on comprehensive medical requirements
        const PETCT_TEMPLATE = {
            sections: ['History', 'Comparison', 'Technique', 'Findings', 'Impression', 'Alternate Impression for Comparison'],
            findingsSubcategories: ['Head/Neck', 'Chest', 'Abdomen/Pelvis', 'MSK/Integument'],
            
            mandatoryPhrases: {
                'Head/Neck': {
                    noFindings: 'No suspicious activity or lymphadenopathy.',
                    withFindings: 'No other suspicious activity or lymphadenopathy.'
                },
                'Chest': {
                    noFindings: 'No suspicious activity or lymphadenopathy. No pulmonary nodules.',
                    withFindings: 'No other suspicious activity or lymphadenopathy.',
                    noNodules: 'No pulmonary nodules.',
                    noOtherNodules: 'No other pulmonary nodules.'
                },
                'Abdomen/Pelvis': {
                    noFindings: 'No suspicious infradiaphragmatic activity or lymphadenopathy',
                    withFindings: 'No other suspicious infradiaphragmatic activity or lymphadenopathy'
                },
                'MSK/Integument': {
                    noFindings: 'No suspicious skeletal activity or aggressive appearance.',
                    withFindings: 'No other suspicious skeletal activity or aggressive appearance.'
                }
            },

            tracerRules: {
                'FDG': { startPhrase: 'Fasting low dose PET/CT', needsFasting: true },
                'Ga-68-PSMA': { startPhrase: 'Low dose PET/CT', needsFasting: false },
                'Ga-68-DOTATATE': { startPhrase: 'Low dose PET/CT', needsFasting: false },
                'FDG-Cardiac': { startPhrase: 'Ketogenic low dose PET/CT', needsFasting: false }
            },

            coverageConversions: {
                'Whole Body': 'eyes to thighs',
                'Total Body': 'vertex to toes',
                'Brain and Whole Body': 'vertex to thighs',
                'Brain plus eyes to thighs': 'brain and eyes to thighs',
                'whole body': 'eyes to thighs',
                'total body': 'vertex to toes',
                'brain and whole body': 'vertex to thighs'
            },

            terminologyMap: {
                'speculated': 'spiculated',
                'Speculated': 'Spiculated'
            }
        };

        // Enhanced PET/CT Report Generator with comprehensive medical logic
        class PETCTReportGenerator {
            constructor(template) {
                this.template = template;
            }

            generateReport(dictation, options = {}) {
                const parsed = this.parseDictation(dictation);
                const metadata = {
                    tracer_detected: parsed.tracer,
                    coverage_area: parsed.coverage,
                    sections_generated: this.template.sections,
                    findings_subcategories: this.template.findingsSubcategories,
                    surgical_bed_included: parsed.hasProstatectomy,
                    measurements_converted: this.countMeasurements(dictation),
                    processing_time: Date.now()
                };

                const startTime = metadata.processing_time;
                
                const report = [
                    this.buildHistory(parsed.history),
                    this.buildComparison(parsed.comparison),
                    this.buildTechnique(parsed.tracer, parsed.coverage),
                    this.buildFindings(parsed, dictation),
                    this.buildImpression(parsed.impression),
                    this.buildAlternateImpression(parsed)
                ].join('\n\n');

                metadata.processing_time = (Date.now() - startTime) / 1000;

                return { report, metadata };
            }

            parseDictation(dictation) {
                return {
                    tracer: this.extractTracer(dictation),
                    coverage: this.extractCoverage(dictation),
                    history: this.extractHistory(dictation),
                    comparison: this.extractComparison(dictation),
                    findings: this.extractDetailedFindings(dictation),
                    impression: this.extractImpression(dictation),
                    hasProstatectomy: this.checkProstatectomy(dictation),
                    incidentalFindings: this.extractIncidentalFindings(dictation)
                };
            }

            extractTracer(text) {
                if (/PSMA/i.test(text)) return 'Ga-68-PSMA';
                if (/DOTATATE/i.test(text)) return 'Ga-68-DOTATATE';
                if (/cardiac.*FDG/i.test(text)) return 'FDG-Cardiac';
                return 'FDG';
            }

            extractCoverage(text) {
                const patterns = Object.keys(this.template.coverageConversions);
                const found = patterns.find(pattern => 
                    new RegExp(pattern, 'i').test(text)
                );
                return found || 'eyes to thighs';
            }

            extractHistory(text) {
                const match = text.match(/history[:\s]+(.*?)(?=comparison|technique|findings|$)/is);
                return match ? match[1].trim() : '[History not specified]';
            }

            extractComparison(text) {
                const match = text.match(/comparison[:\s]+(.*?)(?=technique|findings|$)/is);
                return match ? match[1].trim() : 'None';
            }

            extractImpression(text) {
                const match = text.match(/impression[:\s]+(.*?)$/is);
                return match ? match[1].trim() : '[Impression not provided]';
            }

            extractDetailedFindings(text) {
                const findings = {
                    'Head/Neck': [],
                    'Chest': [],
                    'Abdomen/Pelvis': [],
                    'MSK/Integument': []
                };

                // Extract findings section
                const findingsMatch = text.match(/findings[:\s]+(.*?)(?=impression|$)/is);
                if (!findingsMatch) return findings;

                const findingsText = findingsMatch[1];

                // Look for specific anatomical mentions and measurements
                const measurements = this.extractMeasurements(findingsText);
                const activities = this.extractActivities(findingsText);
                const imageRefs = this.extractImageReferences(findingsText);

                // Categorize findings based on anatomical regions
                this.categorizeFindings(findingsText, findings, measurements, activities, imageRefs);

                return findings;
            }

            extractMeasurements(text) {
                const measurements = [];
                const measurementRegex = /(\d+\.?\d*)\s*(mm|cm)/gi;
                let match;
                while ((match = measurementRegex.exec(text)) !== null) {
                    measurements.push({
                        value: parseFloat(match[1]),
                        unit: match[2].toLowerCase(),
                        fullMatch: match[0],
                        context: text.substring(Math.max(0, match.index - 50), match.index + 50)
                    });
                }
                return measurements;
            }

            extractActivities(text) {
                const activities = [];
                const activityRegex = /SUVmax\s*([\d\.]+)/gi;
                let match;
                while ((match = activityRegex.exec(text)) !== null) {
                    activities.push({
                        value: parseFloat(match[1]),
                        fullMatch: match[0],
                        context: text.substring(Math.max(0, match.index - 50), match.index + 50)
                    });
                }
                return activities;
            }

            extractImageReferences(text) {
                const imageRefs = [];
                const imageRegex = /image\s*(\d+)\s*of\s*(\d+)[^.]*series\s*(\d+)/gi;
                let match;
                while ((match = imageRegex.exec(text)) !== null) {
                    imageRefs.push({
                        imageNum: match[1],
                        totalImages: match[2],
                        series: match[3],
                        fullMatch: match[0],
                        context: text.substring(Math.max(0, match.index - 30), match.index + match[0].length + 30)
                    });
                }
                return imageRefs;
            }

            categorizeFindings(text, findings, measurements, activities, imageRefs) {
                // Simple categorization based on anatomical keywords
                const anatomicalKeywords = {
                    'Head/Neck': ['head', 'neck', 'cervical', 'thyroid', 'salivary'],
                    'Chest': ['chest', 'lung', 'pulmonary', 'thorax', 'mediastin', 'hilar', 'coronary'],
                    'Abdomen/Pelvis': ['abdomen', 'pelvis', 'liver', 'kidney', 'prostate', 'bladder', 'iliac', 'renal'],
                    'MSK/Integument': ['bone', 'spine', 'vertebr', 'skeletal', 'lumbar', 'thoracic', 'cervical', 'degenerative']
                };

                // Check for specific findings in text
                Object.entries(anatomicalKeywords).forEach(([category, keywords]) => {
                    const categoryPattern = new RegExp(keywords.join('|'), 'i');
                    if (categoryPattern.test(text)) {
                        // Extract relevant sentences
                        const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                        sentences.forEach(sentence => {
                            if (categoryPattern.test(sentence)) {
                                const finding = {
                                    description: sentence.trim(),
                                    measurements: measurements.filter(m => sentence.includes(m.fullMatch)),
                                    activities: activities.filter(a => sentence.includes(a.fullMatch)),
                                    imageRefs: imageRefs.filter(r => sentence.includes(r.fullMatch))
                                };
                                
                                if (finding.measurements.length > 0 || finding.activities.length > 0 || 
                                    /nodule|lesion|mass|lymph|activity/i.test(sentence)) {
                                    findings[category].push(finding);
                                }
                            }
                        });
                    }
                });
            }

            extractIncidentalFindings(text) {
                const incidentalPatterns = [
                    /coronary.*calcification/i,
                    /hepatic.*cyst/i,
                    /renal.*cyst/i,
                    /degenerative.*change/i,
                    /physiologic.*uptake/i
                ];

                const incidentals = [];
                incidentalPatterns.forEach(pattern => {
                    const matches = text.match(pattern);
                    if (matches) {
                        incidentals.push(matches[0]);
                    }
                });

                return incidentals;
            }

            checkProstatectomy(text) {
                const hasProstatectomy = /prostatectomy|pelvic surgery/i.test(text);
                const prostatePresent = /prostate.*present|prostate.*intact|prostate.*gland|prostate.*nodule|prostate.*activity|prostate.*zones|apex.*prostate|mid.*gland|BPH|benign prostatic/i.test(text);
                return hasProstatectomy && !prostatePresent;
            }

            buildTechnique(tracer, coverage) {
                const rule = this.template.tracerRules[tracer] || this.template.tracerRules['FDG'];
                const convertedCoverage = this.template.coverageConversions[coverage] || coverage;
                
                return `**Technique**: ${rule.startPhrase} ${convertedCoverage} with ${tracer}.`;
            }

            buildFindings(parsed, originalText) {
                let result = '**Findings**:';
                
                this.template.findingsSubcategories.forEach((category, index) => {
                    const categoryFindings = parsed.findings[category] || [];
                    const hasFindings = categoryFindings.length > 0;
                    
                    result += `\n**${category}**: `;
                    
                    if (hasFindings) {
                        // Format the findings
                        const formattedFindings = categoryFindings.map(finding => {
                            let desc = this.convertMeasurements(finding.description);
                            desc = this.applyTerminologyCorrections(desc);
                            
                            // Add image references if available
                            if (finding.imageRefs && finding.imageRefs.length > 0) {
                                const imageRef = finding.imageRefs[0];
                                if (!desc.includes('(Image')) {
                                    desc += ` (Image ${imageRef.imageNum} of ${imageRef.totalImages}, series ${imageRef.series})`;
                                }
                            }
                            
                            return desc;
                        }).join('. ');

                        result += formattedFindings + '. ';
                        result += this.template.mandatoryPhrases[category].withFindings;
                    } else {
                        result += this.template.mandatoryPhrases[category].noFindings;
                    }

                    // Special logic for Abdomen/Pelvis surgical bed
                    if (category === 'Abdomen/Pelvis' && parsed.hasProstatectomy) {
                        if (!result.includes(', including the pelvic surgical bed')) {
                            result = result.replace(/lymphadenopathy(?!\w)/, 'lymphadenopathy, including the pelvic surgical bed');
                        }
                    }

                    // Handle pulmonary nodules for Chest
                    if (category === 'Chest') {
                        const noduleCount = categoryFindings.filter(f => /nodule/i.test(f.description)).length;
                        if (noduleCount === 0) {
                            // Already included in mandatory phrase
                        } else if (noduleCount <= 3) {
                            if (!result.includes('No other pulmonary nodules')) {
                                result += ' No other pulmonary nodules.';
                            }
                        }
                        
                        // Add incidental findings
                        if (/coronary.*calcification/i.test(originalText)) {
                            result += ' Coronary artery calcification noted.';
                        }
                    }

                    // Add other incidental findings
                    if (category === 'Abdomen/Pelvis' && /renal.*cyst|hepatic.*cyst/i.test(originalText)) {
                        const cystMatch = originalText.match(/(renal|hepatic).*cyst[^.]*/i);
                        if (cystMatch && !result.includes(cystMatch[0])) {
                            result += ` ${cystMatch[0].charAt(0).toUpperCase() + cystMatch[0].slice(1)}.`;
                        }
                    }

                    if (category === 'MSK/Integument' && /degenerative.*change/i.test(originalText)) {
                        const degMatch = originalText.match(/degenerative.*change[^.]*/i);
                        if (degMatch && !result.includes(degMatch[0])) {
                            result += ` ${degMatch[0].charAt(0).toUpperCase() + degMatch[0].slice(1)}.`;
                        }
                    }
                    
                    if (index < this.template.findingsSubcategories.length - 1) {
                        result += '\n';
                    }
                });

                return result;
            }

            convertMeasurements(text) {
                // Convert cm to mm
                return text.replace(/(\d+\.?\d*)\s*cm/gi, (match, num) => {
                    return `${Math.round(parseFloat(num) * 10)} mm`;
                });
            }

            applyTerminologyCorrections(text) {
                Object.entries(this.template.terminologyMap).forEach(([wrong, correct]) => {
                    text = text.replace(new RegExp(wrong, 'gi'), correct);
                });
                return text;
            }

            countMeasurements(text) {
                const measurements = text.match(/\d+\.?\d*\s*cm/gi) || [];
                return measurements.length;
            }

            buildHistory(history) {
                return `**History**: ${history}`;
            }

            buildComparison(comparison) {
                return `**Comparison**: ${comparison}`;
            }

            buildImpression(impression) {
                return `**Impression**: ${impression}`;
            }

            buildAlternateImpression(parsed) {
                // Generate summary based on findings from this report only
                const allFindings = Object.values(parsed.findings).flat();
                const hasPositiveFindings = allFindings.length > 0;

                if (hasPositiveFindings) {
                    let summary = '**Alternate Impression for Comparison**: ';
                    const findingSummaries = [];

                    // Summarize key positive findings
                    Object.entries(parsed.findings).forEach(([category, findings]) => {
                        if (findings.length > 0) {
                            findings.forEach(finding => {
                                const measurements = finding.measurements || [];
                                const activities = finding.activities || [];
                                
                                if (measurements.length > 0 || activities.length > 0) {
                                    let summaryText = '';
                                    if (measurements.length > 0) {
                                        const sizeMm = measurements[0].unit === 'cm' ? 
                                            Math.round(measurements[0].value * 10) : measurements[0].value;
                                        summaryText += `${sizeMm} mm `;
                                    }
                                    
                                    // Extract key anatomical location
                                    const locationMatch = finding.description.match(/(left|right)?\s*(external iliac|vertebr|hilar|upper lobe|lower lobe|lymph node|lesion|mass|nodule)/i);
                                    if (locationMatch) {
                                        summaryText += locationMatch[0].toLowerCase();
                                    }
                                    
                                    if (summaryText.trim()) {
                                        findingSummaries.push(summaryText.trim());
                                    }
                                }
                            });
                        }
                    });

                    if (findingSummaries.length > 0) {
                        summary += findingSummaries.join(' and ') + '. ';
                    }

                    // Add negative findings summary
                    const negativeAreas = [];
                    Object.entries(parsed.findings).forEach(([category, findings]) => {
                        if (findings.length === 0) {
                            negativeAreas.push(category.toLowerCase());
                        }
                    });

                    if (negativeAreas.length > 0) {
                        summary += `No suspicious activity in ${negativeAreas.join(' or ')}.`;
                    }

                    return summary;
                } else {
                    return '**Alternate Impression for Comparison**: No suspicious activity identified in any region examined.';
                }
            }

            validateDictation(dictation) {
                const validation = {
                    valid: true,
                    warnings: [],
                    suggestions: [],
                    detected_elements: {
                        tracer: this.extractTracer(dictation),
                        coverage: this.extractCoverage(dictation),
                        has_history: /history[:\s]/i.test(dictation),
                        has_impression: /impression[:\s]/i.test(dictation),
                        has_findings: /findings|lesion|nodule|activity/i.test(dictation),
                        surgical_history: this.checkProstatectomy(dictation)
                    }
                };

                if (!validation.detected_elements.has_history) {
                    validation.warnings.push("No clear history section detected");
                    validation.suggestions.push("Include patient history information");
                }

                if (!validation.detected_elements.has_impression) {
                    validation.warnings.push("No impression section found");
                    validation.suggestions.push("Add clinical impression from radiologist");
                }

                if (!validation.detected_elements.has_findings) {
                    validation.warnings.push("No specific findings mentioned");
                    validation.suggestions.push("Include detailed findings or state if study is normal");
                }

                if (!/comparison[:\s]/i.test(dictation)) {
                    validation.suggestions.push("Consider adding comparison to previous studies if available");
                }

                return validation;
            }
        }

        // API Handler Functions
        async function handleAPIRequest(method, endpoint, data) {
            if (method === 'POST' && endpoint === '/generate-report') {
                try {
                    const generator = new PETCTReportGenerator(PETCT_TEMPLATE);
                    const result = generator.generateReport(data.dictation, data.options || {});
                    
                    return {
                        success: true,
                        ...result
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: "Could not process dictation: " + error.message,
                        error_code: "PROCESSING_ERROR"
                    };
                }
            } else if (method === 'POST' && endpoint === '/validate-dictation') {
                try {
                    const generator = new PETCTReportGenerator(PETCT_TEMPLATE);
                    const validation = generator.validateDictation(data.dictation);
                    
                    return validation;
                } catch (error) {
                    return {
                        valid: false,
                        error: "Validation failed: " + error.message
                    };
                }
            }
            
            return { success: false, error: "Endpoint not found", error_code: "NOT_FOUND" };
        }

        // Test Interface Functions
        async function testGeneration() {
            const dictation = document.getElementById('dictation-input').value;
            
            if (!dictation.trim()) {
                showResult('error', 'Please enter some dictation text to test.');
                return;
            }

            showResult('warning', 'üîÑ Processing medical dictation...');
            
            try {
                const result = await handleAPIRequest('POST', '/generate-report', { 
                    dictation,
                    options: {
                        include_image_references: true,
                        convert_measurements: true,
                        strict_formatting: true
                    }
                });
                
                if (result.success) {
                    const resultDiv = document.getElementById('result');
                    resultDiv.innerHTML = `
                        <div class="status success">‚úÖ PET/CT Report Generated Successfully</div>
                        <pre>${result.report}</pre>
                        <div class="metadata">
                            <strong>Processing Details:</strong><br>
                            ‚Ä¢ Tracer Detected: ${result.metadata.tracer_detected}<br>
                            ‚Ä¢ Coverage Area: ${result.metadata.coverage_area}<br>
                            ‚Ä¢ Measurements Converted: ${result.metadata.measurements_converted}<br>
                            ‚Ä¢ Surgical Bed Logic: ${result.metadata.surgical_bed_included ? 'Applied' : 'Not Applied'}<br>
                            ‚Ä¢ Processing Time: ${result.metadata.processing_time.toFixed(3)}s
                        </div>
                    `;
                } else {
                    showResult('error', `‚ùå Error: ${result.error}`);
                }
            } catch (error) {
                showResult('error', `‚ùå Unexpected error: ${error.message}`);
            }
        }

        async function validateDictation() {
            const dictation = document.getElementById('dictation-input').value;
            
            if (!dictation.trim()) {
                showResult('error', 'Please enter some dictation text to validate.');
                return;
            }

            try {
                const result = await handleAPIRequest('POST', '/validate-dictation', { dictation });
                
                const statusClass = result.valid ? 'success' : 'warning';
                const statusIcon = result.valid ? '‚úÖ' : '‚ö†Ô∏è';
                
                const resultDiv = document.getElementById('result');
                resultDiv.innerHTML = `
                    <div class="status ${statusClass}">${statusIcon} Validation Results</div>
                    <div class="metadata">
                        <strong>Detected Elements:</strong><br>
                        ‚Ä¢ Tracer: ${result.detected_elements.tracer}<br>
                        ‚Ä¢ Coverage: ${result.detected_elements.coverage}<br>
                        ‚Ä¢ Has History: ${result.detected_elements.has_history ? '‚úÖ' : '‚ùå'}<br>
                        ‚Ä¢ Has Impression: ${result.detected_elements.has_impression ? '‚úÖ' : '‚ùå'}<br>
                        ‚Ä¢ Has Findings: ${result.detected_elements.has_findings ? '‚úÖ' : '‚ùå'}<br>
                        ‚Ä¢ Surgical History: ${result.detected_elements.surgical_history ? '‚úÖ' : '‚ùå'}
                        
                        ${result.warnings.length > 0 ? `<br><br><strong>Warnings:</strong><br>‚Ä¢ ${result.warnings.join('<br>‚Ä¢ ')}` : ''}
                        ${result.suggestions.length > 0 ? `<br><br><strong>Suggestions:</strong><br>‚Ä¢ ${result.suggestions.join('<br>‚Ä¢ ')}` : ''}
                    </div>
                `;
            } catch (error) {
                showResult('error', `‚ùå Validation error: ${error.message}`);
            }
        }

        function clearResults() {
            document.getElementById('result').innerHTML = '';
            document.getElementById('dictation-input').value = '';
        }

        function showResult(type, message) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // External API Interface (for ChatGPT Custom Actions)
        window.addEventListener('message', async (event) => {
            if (event.data.type === 'API_REQUEST') {
                const response = await handleAPIRequest(
                    event.data.method, 
                    event.data.path, 
                    event.data.data
                );
                event.source.postMessage({
                    type: 'API_RESPONSE',
                    id: event.data.id,
                    response: response
                }, '*');
            }
        });

        // HTTP Fetch Override for External Calls
        if (typeof window !== 'undefined' && window.fetch) {
            const originalFetch = window.fetch;
            window.fetch = function(url, options = {}) {
                if (url.includes('medical-transcription') || url.includes('/generate-report')) {
                    return new Promise(async (resolve) => {
                        try {
                            const data = options.body ? JSON.parse(options.body) : {};
                            const endpoint = url.includes('validate') ? '/validate-dictation' : '/generate-report';
                            const response = await handleAPIRequest(options.method || 'POST', endpoint, data);
                            
                            resolve({
                                ok: response.success !== false,
                                status: response.success !== false ? 200 : 400,
                                json: () => Promise.resolve(response),
                                text: () => Promise.resolve(JSON.stringify(response))
                            });
                        } catch (error) {
                            resolve({
                                ok: false,
                                status: 500,
                                json: () => Promise.resolve({ 
                                    success: false, 
                                    error: error.message,
                                    error_code: 'INTERNAL_ERROR'
                                })
                            });
                        }
                    });
                }
                return originalFetch.apply(this, arguments);
            };
        }

        // Initialize
        console.log('üè• Enhanced Medical PET/CT Transcription API loaded and ready');
        console.log('Endpoint: https://thechatbotgenius.com/api/medical-transcription.html');
        console.log('Features: Comprehensive medical formatting, measurement conversion, surgical bed logic');
    </script>
</body>
</html>