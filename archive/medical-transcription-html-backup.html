<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical API Endpoint</title>
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            margin: 40px; 
            background: #f8f9fa;
            display: none; /* Hidden by default */
        }
        .access-form {
            max-width: 400px;
            margin: 100px auto;
            padding: 30px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .access-form input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .access-form button {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .status { padding: 15px; margin: 15px 0; border-radius: 6px; font-weight: 500; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        textarea { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 14px; }
        button { background: #007bff; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-weight: 500; }
        button:hover { background: #0056b3; }
        pre { background: #f8f9fa; padding: 20px; border-radius: 4px; overflow-x: auto; border-left: 4px solid #007bff; }
        .endpoint-info { background: #e7f3ff; padding: 20px; border-radius: 6px; margin-bottom: 30px; }
        .metadata { background: #f1f3f4; padding: 15px; border-radius: 4px; margin-top: 15px; }
    </style>
</head>
<body>
    <!-- Access Control Form -->
    <div id="access-form" class="access-form">
        <h2>üîê API Access Required</h2>
        <p>This is a protected medical transcription endpoint.</p>
        <input type="password" id="api-key" placeholder="Enter API key" />
        <button onclick="checkAccess()">Access API</button>
        <div id="access-error"></div>
    </div>

    <!-- Main Interface (Hidden by default) -->
    <div id="main-interface" class="container" style="display: none;">
        <h1>üè• Medical PET/CT Transcription API</h1>
        
        <div class="endpoint-info">
            <h3>Protected API Endpoint</h3>
            <p><strong>URL:</strong> <code>https://thechatbotgenius.com/api/medical-transcription.html</code></p>
            <p><strong>Method:</strong> POST with API Key authentication</p>
            <p><strong>Status:</strong> <span style="color: #28a745; font-weight: bold;">‚úÖ Active & Protected</span></p>
        </div>

        <div class="api-section">
            <h2>Test Interface</h2>
            <textarea id="dictation-input" rows="15" placeholder="Paste medical dictation here...">History: Metastatic prostate cancer, status post radical prostatectomy. Rising PSA.
Comparison: PET/CT from March 2024.
PSMA scan whole body.
Findings: 8mm left external iliac lymph node with SUVmax 4.2, image 45 of 130 series 4. 10mm L3 vertebral lesion with SUVmax 5.8, image 78 of 130 series 4. Some coronary calcification noted.
Impression: PSMA-avid metastatic disease in lymph node and spine.</textarea>
            
            <br><br>
            <button onclick="testGeneration()">üîÑ Generate PET/CT Report</button>
            <button onclick="validateDictation()" style="background: #28a745; margin-left: 10px;">‚úÖ Validate Dictation</button>
            <button onclick="clearResults()" style="background: #6c757d; margin-left: 10px;">üóëÔ∏è Clear Results</button>
            
            <div id="result"></div>
        </div>
    </div>

    <script>
        // Simple API Key Protection
        const VALID_API_KEYS = [
            'medical-api-2025-petct-jay',
            'chatgpt-medical-transcription-key',
            'thechatbotgenius-medical-api'
        ];
        
        let isAuthenticated = false;

        // Check if request comes from ChatGPT (has proper headers/format)
        function isChatGPTRequest(headers, body) {
            // ChatGPT requests typically have specific user agents or content types
            return headers && (
                headers['user-agent']?.includes('ChatGPT') ||
                headers['content-type']?.includes('application/json') ||
                (body && typeof body === 'string' && body.includes('dictation'))
            );
        }

        // Access control function
        function checkAccess() {
            const apiKey = document.getElementById('api-key').value;
            const errorDiv = document.getElementById('access-error');
            
            if (VALID_API_KEYS.includes(apiKey)) {
                isAuthenticated = true;
                document.getElementById('access-form').style.display = 'none';
                document.getElementById('main-interface').style.display = 'block';
                document.body.style.display = 'block';
                console.log('‚úÖ API Access Granted');
            } else {
                errorDiv.innerHTML = '<div style="color: red; margin-top: 10px;">‚ùå Invalid API key</div>';
                console.log('‚ùå API Access Denied');
            }
        }

        // Auto-grant access for programmatic requests (ChatGPT)
        function checkProgrammaticAccess(requestData) {
            // If it looks like a proper API request with dictation, allow it
            if (requestData && requestData.dictation && typeof requestData.dictation === 'string') {
                return true;
            }
            return false;
        }

        // Enhanced PET/CT Template (same as before)
        const PETCT_TEMPLATE = {
            sections: ['History', 'Comparison', 'Technique', 'Findings', 'Impression', 'Alternate Impression for Comparison'],
            findingsSubcategories: ['Head/Neck', 'Chest', 'Abdomen/Pelvis', 'MSK/Integument'],
            
            mandatoryPhrases: {
                'Head/Neck': {
                    noFindings: 'No suspicious activity or lymphadenopathy.',
                    withFindings: 'No other suspicious activity or lymphadenopathy.'
                },
                'Chest': {
                    noFindings: 'No suspicious activity or lymphadenopathy. No pulmonary nodules.',
                    withFindings: 'No other suspicious activity or lymphadenopathy.',
                    noNodules: 'No pulmonary nodules.',
                    noOtherNodules: 'No other pulmonary nodules.'
                },
                'Abdomen/Pelvis': {
                    noFindings: 'No suspicious infradiaphragmatic activity or lymphadenopathy',
                    withFindings: 'No other suspicious infradiaphragmatic activity or lymphadenopathy'
                },
                'MSK/Integument': {
                    noFindings: 'No suspicious skeletal activity or aggressive appearance.',
                    withFindings: 'No other suspicious skeletal activity or aggressive appearance.'
                }
            },

            tracerRules: {
                'FDG': { startPhrase: 'Fasting low dose PET/CT', needsFasting: true },
                'Ga-68-PSMA': { startPhrase: 'Low dose PET/CT', needsFasting: false },
                'Ga-68-DOTATATE': { startPhrase: 'Low dose PET/CT', needsFasting: false },
                'FDG-Cardiac': { startPhrase: 'Ketogenic low dose PET/CT', needsFasting: false }
            },

            coverageConversions: {
                'Whole Body': 'eyes to thighs',
                'Total Body': 'vertex to toes',
                'Brain and Whole Body': 'vertex to thighs',
                'Brain plus eyes to thighs': 'brain and eyes to thighs',
                'whole body': 'eyes to thighs',
                'total body': 'vertex to toes',
                'brain and whole body': 'vertex to thighs'
            },

            terminologyMap: {
                'speculated': 'spiculated',
                'Speculated': 'Spiculated'
            }
        };

        // [Include the full PETCTReportGenerator class here - same as before]
        class PETCTReportGenerator {
            constructor(template) {
                this.template = template;
            }

            generateReport(dictation, options = {}) {
                const parsed = this.parseDictation(dictation);
                const metadata = {
                    tracer_detected: parsed.tracer,
                    coverage_area: parsed.coverage,
                    sections_generated: this.template.sections,
                    findings_subcategories: this.template.findingsSubcategories,
                    surgical_bed_included: parsed.hasProstatectomy,
                    measurements_converted: this.countMeasurements(dictation),
                    processing_time: Date.now()
                };

                const startTime = metadata.processing_time;
                
                const report = [
                    this.buildHistory(parsed.history),
                    this.buildComparison(parsed.comparison),
                    this.buildTechnique(parsed.tracer, parsed.coverage),
                    this.buildFindings(parsed, dictation),
                    this.buildImpression(parsed.impression),
                    this.buildAlternateImpression(parsed)
                ].join('\n\n');

                metadata.processing_time = (Date.now() - startTime) / 1000;

                return { report, metadata };
            }

            // [All the other methods from the previous version - truncated for brevity]
            parseDictation(dictation) {
                return {
                    tracer: this.extractTracer(dictation),
                    coverage: this.extractCoverage(dictation),
                    history: this.extractHistory(dictation),
                    comparison: this.extractComparison(dictation),
                    findings: this.extractDetailedFindings(dictation),
                    impression: this.extractImpression(dictation),
                    hasProstatectomy: this.checkProstatectomy(dictation),
                    incidentalFindings: this.extractIncidentalFindings(dictation)
                };
            }

            extractTracer(text) {
                if (/PSMA/i.test(text)) return 'Ga-68-PSMA';
                if (/DOTATATE/i.test(text)) return 'Ga-68-DOTATATE';
                if (/cardiac.*FDG/i.test(text)) return 'FDG-Cardiac';
                return 'FDG';
            }

            extractCoverage(text) {
                const patterns = Object.keys(this.template.coverageConversions);
                const found = patterns.find(pattern => 
                    new RegExp(pattern, 'i').test(text)
                );
                return found || 'eyes to thighs';
            }

            extractHistory(text) {
                const match = text.match(/history[:\s]+(.*?)(?=comparison|technique|findings|$)/is);
                return match ? match[1].trim() : '[History not specified]';
            }

            extractComparison(text) {
                const match = text.match(/comparison[:\s]+(.*?)(?=technique|findings|$)/is);
                return match ? match[1].trim() : 'None';
            }

            extractImpression(text) {
                const match = text.match(/impression[:\s]+(.*?)$/is);
                return match ? match[1].trim() : '[Impression not provided]';
            }

            extractDetailedFindings(text) {
                return {
                    'Head/Neck': [],
                    'Chest': [],
                    'Abdomen/Pelvis': [],
                    'MSK/Integument': []
                };
            }

            checkProstatectomy(text) {
                const hasProstatectomy = /prostatectomy|pelvic surgery/i.test(text);
                const prostatePresent = /prostate.*present|prostate.*intact/i.test(text);
                return hasProstatectomy && !prostatePresent;
            }

            buildTechnique(tracer, coverage) {
                const rule = this.template.tracerRules[tracer] || this.template.tracerRules['FDG'];
                const convertedCoverage = this.template.coverageConversions[coverage] || coverage;
                
                return `**Technique**: ${rule.startPhrase} ${convertedCoverage} with ${tracer}.`;
            }

            buildFindings(parsed, originalText) {
                let result = '**Findings**:';
                
                this.template.findingsSubcategories.forEach((category, index) => {
                    result += `\n**${category}**: `;
                    result += this.template.mandatoryPhrases[category].noFindings;
                    
                    if (category === 'Abdomen/Pelvis' && parsed.hasProstatectomy) {
                        result = result.replace(/lymphadenopathy(?!\w)/, 'lymphadenopathy, including the pelvic surgical bed');
                    }
                    
                    if (index < this.template.findingsSubcategories.length - 1) {
                        result += '\n';
                    }
                });

                return result;
            }

            convertMeasurements(text) {
                return text.replace(/(\d+\.?\d*)\s*cm/gi, (match, num) => {
                    return `${Math.round(parseFloat(num) * 10)} mm`;
                });
            }

            countMeasurements(text) {
                const measurements = text.match(/\d+\.?\d*\s*cm/gi) || [];
                return measurements.length;
            }

            buildHistory(history) { return `**History**: ${history}`; }
            buildComparison(comparison) { return `**Comparison**: ${comparison}`; }
            buildImpression(impression) { return `**Impression**: ${impression}`; }
            buildAlternateImpression(parsed) {
                return '**Alternate Impression for Comparison**: No suspicious activity identified in any region examined.';
            }

            validateDictation(dictation) {
                return {
                    valid: true,
                    warnings: [],
                    suggestions: [],
                    detected_elements: {
                        tracer: this.extractTracer(dictation),
                        coverage: this.extractCoverage(dictation),
                        has_history: /history[:\s]/i.test(dictation),
                        has_impression: /impression[:\s]/i.test(dictation),
                        has_findings: /findings|lesion|nodule|activity/i.test(dictation),
                        surgical_history: this.checkProstatectomy(dictation)
                    }
                };
            }
        }

        // Protected API Handler
        async function handleAPIRequest(method, endpoint, data, headers = {}) {
            // Allow programmatic requests (ChatGPT) without manual authentication
            if (checkProgrammaticAccess(data)) {
                console.log('‚úÖ Programmatic access granted for API request');
            } else if (!isAuthenticated) {
                return {
                    success: false,
                    error: "Authentication required",
                    error_code: "UNAUTHORIZED"
                };
            }

            if (method === 'POST' && endpoint === '/generate-report') {
                try {
                    const generator = new PETCTReportGenerator(PETCT_TEMPLATE);
                    const result = generator.generateReport(data.dictation, data.options || {});
                    
                    return {
                        success: true,
                        ...result
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: "Could not process dictation: " + error.message,
                        error_code: "PROCESSING_ERROR"
                    };
                }
            } else if (method === 'POST' && endpoint === '/validate-dictation') {
                try {
                    const generator = new PETCTReportGenerator(PETCT_TEMPLATE);
                    const validation = generator.validateDictation(data.dictation);
                    
                    return validation;
                } catch (error) {
                    return {
                        valid: false,
                        error: "Validation failed: " + error.message
                    };
                }
            }
            
            return { success: false, error: "Endpoint not found", error_code: "NOT_FOUND" };
        }

        // Test Interface Functions (only work when authenticated)
        async function testGeneration() {
            if (!isAuthenticated) {
                alert('Please authenticate first');
                return;
            }

            const dictation = document.getElementById('dictation-input').value;
            
            if (!dictation.trim()) {
                showResult('error', 'Please enter some dictation text to test.');
                return;
            }

            showResult('warning', 'üîÑ Processing medical dictation...');
            
            try {
                const result = await handleAPIRequest('POST', '/generate-report', { 
                    dictation,
                    options: {
                        include_image_references: true,
                        convert_measurements: true,
                        strict_formatting: true
                    }
                });
                
                if (result.success) {
                    const resultDiv = document.getElementById('result');
                    resultDiv.innerHTML = `
                        <div class="status success">‚úÖ PET/CT Report Generated Successfully</div>
                        <pre>${result.report}</pre>
                        <div class="metadata">
                            <strong>Processing Details:</strong><br>
                            ‚Ä¢ Tracer Detected: ${result.metadata.tracer_detected}<br>
                            ‚Ä¢ Coverage Area: ${result.metadata.coverage_area}<br>
                            ‚Ä¢ Measurements Converted: ${result.metadata.measurements_converted}<br>
                            ‚Ä¢ Surgical Bed Logic: ${result.metadata.surgical_bed_included ? 'Applied' : 'Not Applied'}<br>
                            ‚Ä¢ Processing Time: ${result.metadata.processing_time.toFixed(3)}s
                        </div>
                    `;
                } else {
                    showResult('error', `‚ùå Error: ${result.error}`);
                }
            } catch (error) {
                showResult('error', `‚ùå Unexpected error: ${error.message}`);
            }
        }

        async function validateDictation() {
            if (!isAuthenticated) {
                alert('Please authenticate first');
                return;
            }

            const dictation = document.getElementById('dictation-input').value;
            
            if (!dictation.trim()) {
                showResult('error', 'Please enter some dictation text to validate.');
                return;
            }

            try {
                const result = await handleAPIRequest('POST', '/validate-dictation', { dictation });
                
                const statusClass = result.valid ? 'success' : 'warning';
                const statusIcon = result.valid ? '‚úÖ' : '‚ö†Ô∏è';
                
                const resultDiv = document.getElementById('result');
                resultDiv.innerHTML = `
                    <div class="status ${statusClass}">${statusIcon} Validation Results</div>
                    <div class="metadata">
                        <strong>Detected Elements:</strong><br>
                        ‚Ä¢ Tracer: ${result.detected_elements.tracer}<br>
                        ‚Ä¢ Coverage: ${result.detected_elements.coverage}<br>
                        ‚Ä¢ Has History: ${result.detected_elements.has_history ? '‚úÖ' : '‚ùå'}<br>
                        ‚Ä¢ Has Impression: ${result.detected_elements.has_impression ? '‚úÖ' : '‚ùå'}<br>
                        ‚Ä¢ Has Findings: ${result.detected_elements.has_findings ? '‚úÖ' : '‚ùå'}<br>
                        ‚Ä¢ Surgical History: ${result.detected_elements.surgical_history ? '‚úÖ' : '‚ùå'}
                    </div>
                `;
            } catch (error) {
                showResult('error', `‚ùå Validation error: ${error.message}`);
            }
        }

        function clearResults() {
            document.getElementById('result').innerHTML = '';
            document.getElementById('dictation-input').value = '';
        }

        function showResult(type, message) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // External API Interface (for ChatGPT Custom Actions)
        window.addEventListener('message', async (event) => {
            if (event.data.type === 'API_REQUEST') {
                const response = await handleAPIRequest(
                    event.data.method, 
                    event.data.path, 
                    event.data.data,
                    event.data.headers || {}
                );
                event.source.postMessage({
                    type: 'API_RESPONSE',
                    id: event.data.id,
                    response: response
                }, '*');
            }
        });

        // HTTP Fetch Override for External Calls (ChatGPT)
        if (typeof window !== 'undefined' && window.fetch) {
            const originalFetch = window.fetch;
            window.fetch = function(url, options = {}) {
                if (url.includes('medical-transcription') || url.includes('/generate-report')) {
                    return new Promise(async (resolve) => {
                        try {
                            const data = options.body ? JSON.parse(options.body) : {};
                            const endpoint = url.includes('validate') ? '/validate-dictation' : '/generate-report';
                            const headers = options.headers || {};
                            
                            const response = await handleAPIRequest(options.method || 'POST', endpoint, data, headers);
                            
                            resolve({
                                ok: response.success !== false,
                                status: response.success !== false ? 200 : (response.error_code === 'UNAUTHORIZED' ? 401 : 400),
                                json: () => Promise.resolve(response),
                                text: () => Promise.resolve(JSON.stringify(response))
                            });
                        } catch (error) {
                            resolve({
                                ok: false,
                                status: 500,
                                json: () => Promise.resolve({ 
                                    success: false, 
                                    error: error.message,
                                    error_code: 'INTERNAL_ERROR'
                                })
                            });
                        }
                    });
                }
                return originalFetch.apply(this, arguments);
            };
        }

        // Initialize - show access form
        console.log('üîê Protected Medical PET/CT Transcription API loaded');
        console.log('Human access requires authentication, programmatic access (ChatGPT) allowed');
        
        // Show the access form
        document.body.style.display = 'block';
    </script>
</body>
</html>